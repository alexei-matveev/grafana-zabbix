{"version":3,"sources":["../../src/datasource-zabbix/timeseries.js"],"names":["downsample","datapoints","time_to","ms_interval","func","downsampledSeries","timeWindow","from","to","points_sum","points_num","value_avg","frame","i","length","push","_","max","min","reverse","groupBy","interval","groupByCallback","utils","parseInterval","frames","point","Math","floor","grouped","mapValues","points","map","sortByTime","value","timestamp","Number","groupBy_perf","datapoints_unsorted","grouped_series","frame_values","frame_value","frame_ts","getPointTimeFrame","POINT_TIMESTAMP","point_frame_ts","POINT_VALUE","sumSeries","timeseries","new_timestamps","uniq","flatten","sortBy","interpolated_timeseries","series","timestamps","new_points","difference","new_series","concat","each","interpolateSeries","new_timeseries","sum","j","scale","factor","scale_perf","delta","newSeries","deltaValue","rate","point_prev","valueDelta","timeDelta","COUNT","values","SUM","AVERAGE","values_non_null","getNonNullValues","MIN","MAX","MEDIAN","sorted","left","right","findNearestLeft","findNearestRight","linearInterpolation","point_index","indexOf","nearestRight","nearestLeft","exportedFunctions"],"mappings":"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","file":"timeseries.js","sourcesContent":["/**\n * timeseries.js\n *\n * This module contains functions for working with time series.\n *\n * datapoints - array of points where point is [value, timestamp]. In almost all cases (if other wasn't\n * explicitly said) we assume datapoints are sorted by timestamp. Timestamp is the number of milliseconds\n * since 1 January 1970 00:00:00 UTC.\n *\n */\n\nimport _ from 'lodash';\nimport * as utils from './utils';\n\nconst POINT_VALUE = 0;\nconst POINT_TIMESTAMP = 1;\n\n/**\n * Downsample time series by using given function (avg, min, max).\n */\nfunction downsample(datapoints, time_to, ms_interval, func) {\n  var downsampledSeries = [];\n  var timeWindow = {\n    from: time_to * 1000 - ms_interval,\n    to: time_to * 1000\n  };\n\n  var points_sum = 0;\n  var points_num = 0;\n  var value_avg = 0;\n  var frame = [];\n\n  for (var i = datapoints.length - 1; i >= 0; i -= 1) {\n    if (timeWindow.from < datapoints[i][1] && datapoints[i][1] <= timeWindow.to) {\n      points_sum += datapoints[i][0];\n      points_num++;\n      frame.push(datapoints[i][0]);\n    }\n    else {\n      value_avg = points_num ? points_sum / points_num : 0;\n\n      if (func === \"max\") {\n        downsampledSeries.push([_.max(frame), timeWindow.to]);\n      }\n      else if (func === \"min\") {\n        downsampledSeries.push([_.min(frame), timeWindow.to]);\n      }\n\n      // avg by default\n      else {\n        downsampledSeries.push([value_avg, timeWindow.to]);\n      }\n\n      // Shift time window\n      timeWindow.to = timeWindow.from;\n      timeWindow.from -= ms_interval;\n\n      points_sum = 0;\n      points_num = 0;\n      frame = [];\n\n      // Process point again\n      i++;\n    }\n  }\n  return downsampledSeries.reverse();\n}\n\n/**\n * Group points by given time interval\n * datapoints: [[<value>, <unixtime>], ...]\n */\nfunction groupBy(datapoints, interval, groupByCallback) {\n  var ms_interval = utils.parseInterval(interval);\n\n  // Calculate frame timestamps\n  var frames = _.groupBy(datapoints, function (point) {\n    // Calculate time for group of points\n    return Math.floor(point[1] / ms_interval) * ms_interval;\n  });\n\n  // frame: { '<unixtime>': [[<value>, <unixtime>], ...] }\n  // return [{ '<unixtime>': <value> }, { '<unixtime>': <value> }, ...]\n  var grouped = _.mapValues(frames, function (frame) {\n    var points = _.map(frame, function (point) {\n      return point[0];\n    });\n    return groupByCallback(points);\n  });\n\n  // Convert points to Grafana format\n  return sortByTime(_.map(grouped, function (value, timestamp) {\n    return [Number(value), Number(timestamp)];\n  }));\n}\n\nfunction groupBy_perf(datapoints_unsorted, interval, groupByCallback) {\n\n  // Note that  aggregateBy() does  not sort  the points  by timestamp\n  // after   flattening.    Compare   that  with   sumSeries()   which\n  // does. FIXME: sorting  them just in case may  kill performance and\n  // thus the whole point of groupBy_perf().\n  let datapoints = sortByTime(datapoints_unsorted);\n\n  let ms_interval = utils.parseInterval(interval);\n  let grouped_series = [];\n  let frame_values = [];\n  let frame_value;\n  let frame_ts = datapoints.length ? getPointTimeFrame(datapoints[0][POINT_TIMESTAMP], ms_interval) : 0;\n  let point_frame_ts = frame_ts;\n  let point;\n\n  for (let i=0; i < datapoints.length; i++) {\n    point = datapoints[i];\n    point_frame_ts = getPointTimeFrame(point[POINT_TIMESTAMP], ms_interval);\n    if (point_frame_ts === frame_ts) {\n      frame_values.push(point[POINT_VALUE]);\n    } else if (point_frame_ts > frame_ts) {\n      frame_value = groupByCallback(frame_values);\n      grouped_series.push([frame_value, frame_ts]);\n\n      // Move frame window to next non-empty interval and fill empty by null\n      frame_ts += ms_interval;\n      while (frame_ts < point_frame_ts) {\n        grouped_series.push([null, frame_ts]);\n        frame_ts += ms_interval;\n      }\n      frame_values = [point[POINT_VALUE]];\n    }\n  }\n\n  frame_value = groupByCallback(frame_values);\n  grouped_series.push([frame_value, frame_ts]);\n\n  return grouped_series;\n}\n\n/**\n * Summarize set of time series into one.\n * @param {datapoints[]} timeseries array of time series\n */\nfunction sumSeries(timeseries) {\n\n  // Calculate new points for interpolation\n  var new_timestamps = _.uniq(_.map(_.flatten(timeseries, true), function (point) {\n    return point[1];\n  }));\n  new_timestamps = _.sortBy(new_timestamps);\n\n  var interpolated_timeseries = _.map(timeseries, function (series) {\n    var timestamps = _.map(series, function (point) {\n      return point[1];\n    });\n    var new_points = _.map(_.difference(new_timestamps, timestamps), function (timestamp) {\n      return [null, timestamp];\n    });\n    var new_series = series.concat(new_points);\n    return sortByTime(new_series);\n  });\n\n  _.each(interpolated_timeseries, interpolateSeries);\n\n  var new_timeseries = [];\n  var sum;\n  for (var i = new_timestamps.length - 1; i >= 0; i--) {\n    sum = 0;\n    for (var j = interpolated_timeseries.length - 1; j >= 0; j--) {\n      sum += interpolated_timeseries[j][i][0];\n    }\n    new_timeseries.push([sum, new_timestamps[i]]);\n  }\n\n  return sortByTime(new_timeseries);\n}\n\nfunction scale(datapoints, factor) {\n  return _.map(datapoints, point => {\n    return [\n      point[0] * factor,\n      point[1]\n    ];\n  });\n}\n\nfunction scale_perf(datapoints, factor) {\n  for (let i = 0; i < datapoints.length; i++) {\n    datapoints[i] = [\n      datapoints[i][POINT_VALUE] * factor,\n      datapoints[i][POINT_TIMESTAMP]\n    ];\n  }\n\n  return datapoints;\n}\n\n/**\n * Simple delta. Calculate value delta between points.\n * @param {*} datapoints\n */\nfunction delta(datapoints) {\n  let newSeries = [];\n  let deltaValue;\n  for (var i = 1; i < datapoints.length; i++) {\n    deltaValue = datapoints[i][0] - datapoints[i - 1][0];\n    newSeries.push([deltaValue, datapoints[i][1]]);\n  }\n  return newSeries;\n}\n\n/**\n * Calculates rate per second. Resistant to counter reset.\n * @param {*} datapoints\n */\nfunction rate(datapoints) {\n  let newSeries = [];\n  let point, point_prev;\n  let valueDelta = 0;\n  let timeDelta = 0;\n  for (let i = 1; i < datapoints.length; i++) {\n    point = datapoints[i];\n    point_prev = datapoints[i - 1];\n\n    // Convert ms to seconds\n    timeDelta = (point[POINT_TIMESTAMP] - point_prev[POINT_TIMESTAMP]) / 1000;\n\n    // Handle counter reset - use previous value\n    if (point[POINT_VALUE] >= point_prev[POINT_VALUE]) {\n      valueDelta = (point[POINT_VALUE] - point_prev[POINT_VALUE]) / timeDelta;\n    }\n\n    newSeries.push([valueDelta, point[POINT_TIMESTAMP]]);\n  }\n  return newSeries;\n}\n\nfunction COUNT(values) {\n  return values.length;\n}\n\nfunction SUM(values) {\n  var sum = null;\n  for (let i = 0; i < values.length; i++) {\n    if (values[i] !== null) {\n      sum += values[i];\n    }\n  }\n  return sum;\n}\n\nfunction AVERAGE(values) {\n  let values_non_null = getNonNullValues(values);\n  if (values_non_null.length === 0) {\n    return null;\n  }\n  return SUM(values_non_null) / values_non_null.length;\n}\n\nfunction getNonNullValues(values) {\n  let values_non_null = [];\n  for (let i = 0; i < values.length; i++) {\n    if (values[i] !== null) {\n      values_non_null.push(values[i]);\n    }\n  }\n  return values_non_null;\n}\n\nfunction MIN(values) {\n  return _.min(values);\n}\n\nfunction MAX(values) {\n  return _.max(values);\n}\n\nfunction MEDIAN(values) {\n  var sorted = _.sortBy(values);\n  return sorted[Math.floor(sorted.length / 2)];\n}\n\n///////////////////////\n// Utility functions //\n///////////////////////\n\n/**\n * For given point calculate corresponding time frame.\n *\n * |__*_|_*__|___*| -> |*___|*___|*___|\n *\n * @param {*} timestamp\n * @param {*} ms_interval\n */\nfunction getPointTimeFrame(timestamp, ms_interval) {\n  return Math.floor(timestamp / ms_interval) * ms_interval;\n}\n\nfunction sortByTime(series) {\n  return _.sortBy(series, function (point) {\n    return point[1];\n  });\n}\n\n/**\n * Interpolate series with gaps\n */\nfunction interpolateSeries(series) {\n  var left, right;\n\n  // Interpolate series\n  for (var i = series.length - 1; i >= 0; i--) {\n    if (!series[i][0]) {\n      left = findNearestLeft(series, series[i]);\n      right = findNearestRight(series, series[i]);\n      if (!left) {\n        left = right;\n      }\n      if (!right) {\n        right = left;\n      }\n      series[i][0] = linearInterpolation(series[i][1], left, right);\n    }\n  }\n  return series;\n}\n\nfunction linearInterpolation(timestamp, left, right) {\n  if (left[1] === right[1]) {\n    return (left[0] + right[0]) / 2;\n  } else {\n    return (left[0] + (right[0] - left[0]) / (right[1] - left[1]) * (timestamp - left[1]));\n  }\n}\n\nfunction findNearestRight(series, point) {\n  var point_index = _.indexOf(series, point);\n  var nearestRight;\n  for (var i = point_index; i < series.length; i++) {\n    if (series[i][0] !== null) {\n      return series[i];\n    }\n  }\n  return nearestRight;\n}\n\nfunction findNearestLeft(series, point) {\n  var point_index = _.indexOf(series, point);\n  var nearestLeft;\n  for (var i = point_index; i > 0; i--) {\n    if (series[i][0] !== null) {\n      return series[i];\n    }\n  }\n  return nearestLeft;\n}\n\n////////////\n// Export //\n////////////\n\nconst exportedFunctions = {\n  downsample,\n  groupBy,\n  groupBy_perf,\n  sumSeries,\n  scale,\n  scale_perf,\n  delta,\n  rate,\n  SUM,\n  COUNT,\n  AVERAGE,\n  MIN,\n  MAX,\n  MEDIAN\n};\n\nexport default exportedFunctions;\n"]}